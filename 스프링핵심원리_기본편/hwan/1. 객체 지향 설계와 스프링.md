# 1. 스프링

### EJB 프레임워크

과거 웹 애플리케이션을 구축함에 있어서 EJB라는 기술이 있었다.

당시 EJB는 트랜잭션 관리, 분산기술를 사용함에 있어서 장점이었다.

ORM 기술은 자바 객체를 DB에 저장하기 편하게 만들었다.

하지만 워낙 복잡하였고 컨테이너를 한 번 돌리는데에도 오랜 시간이 걸렸다.

### 스프링

2002년에 로드 존슨은 EJB 없이도 고품질의 확장 가능한 애플리케이션을 개발할 수 있다는 보여주는 책을 발간했다.

기존 EJB에 싫증났던 개발자들은 실제 서비스에 도입하여 쓰기 시작했다.


- 핵심 기술: DI 컨테이너, AOP, 이벤트, 기타
- 웹 기술: MVC, WebFlux
- 데이터 접근 기술: 트랜잭션, JDBC, ORM XML 지원
- 기술 통합: 캐시, 이메일, 원격접근, 스케줄링
- 테스트: 스프링 기반 테스트 지원
- 언어: Kotlin, Groovy

&nbsp;

### 스프링 부트

스프링을 편리하게 사용할 수 있도록 지원한다.

→ 단독으로 실행할 수 있는 스프링 애플리케이션을 쉽게 생성 가능.

→ 별도의 웹 서버 설치하지 않아도 됨.

→ 손 쉬운 빌드 구성을 위한 starter 종속성 제공.

→ 메트릭, 상태 확인, 외부 구성 같은 프로덕션 준비 기능 제공.

&nbsp;

### 릴리즈

- 2003년 스프링 프레임워크 1.0 출시 - XML
- 2003년 스프링 프레임워크 2.0 출시 - XML 편의 기능 지원
- 2009년 스프링 프레임워크 3.0 출시 - 자바 코드로 설정
- 2013년 스프림 프레임워크 4.0 출시 - 자바8
- 2014년 스프링 부트 1.0 출시
- 2017년 스프링 프레임워크 5.0, 스프링 부트 2.0 출시 - 리엑티브 프로그래밍 지원
- 2020년 9월 스프링 프레임워크 5.2.ㅌ, 스프링 부트 2.3.x

&nbsp;

# 2. 객체 지향 프로그래밍

객체 지향 프로그래밍은 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위, 즉 **객체**들의 **모임**으로 파악하고자 하는 것이다. 각각의 **객체**는 **메시지**를 주고받고, 데이터를 처리할 수 있다. **(협력)**

객체 지향 프로그래밍은 프로그램을 **유연**하고 **변경**이 용이하게 만들기 때문에 대규모 소프트웨어 개발에 많이 사용된다.

&nbsp;

### 다형성

스프링은 다형성이 가장 중요하며, 다형성을 극대화해서 이용할 수 있게 도와준다.

**다형성이란?** 어떤 객체의 속성이나 기능이 상황에 따라 **여러 가지 형태를 가질 수** 있는 성질이다.

- 클래스

클래스에서 다형성 예시로 첫 번째는 한 타입의 참조 변수로 여러 타입의 객체를 참조할 수 있다.

두 번째는 조상 클래스 타입의 참조 변수로 자손 클래스의 인스턴스를 참조할 수 있다.

- 메서드

메서드에서의 다형성은 메서드 **오버라이딩**과 메서드 **오버로딩**이 있다.

&nbsp;
### 역할과 구현을 분리

다형성을 이용하면 세상이 단순해지고, 유연해지며 변경도 편리해진다.

다형성을 통해 역할과 구현을 분리하면

- 클라이언트는 대상의 역할(인터페이스)만 알면 된다.
- 클라이언트는 구현 대상의 **내부 구조를 몰라도** 된다.
- 클라이언트는 구현 대상의 **내부 구조가 변경되어도** 영향을 받지 않는다.
- 클라이언트는 구현 **대상 자체를 변경해도** 영향을 받지 않는다.

&nbsp;

자바 언어에서의 다형성의 활용은 아래와 같다.

- 역할 = 인터페이스

```java
public interface MemberRepository {
    void save(Member member);

    Member findBy(Long memberId);
}
```

- 구현=인터페이스를 구현한 클래스, 구현 객체

```java
public class MemoryMemberRepository implements MemberRepository {

    private static Map<Long, Member> store = new HashMap<>();

    @Override
    public void save(Member member) {
        store.put(member.getId(), member);
    }

    @Override
    public Member findBy(Long memberId) {
        return store.get(memberId);
    }
}
```

스프링에서 이야기하는 제어의 역전(IoC), 의존관계 주입(DI)은 다형성을 활용해서 역할과 구현을 편리하게 다룰 수 있도록 지원한다.

&nbsp;

# 3. SOLID 원칙

스프링 **다형성, OCP, DIP를 가능하게 지원**함으로써 클라이언트 코드의 변경 없이 기능을 확장할 수 있게 되었다.

&nbsp;

**OCP와 DIP가 뭐지?**

클린코드로 유명한 로버트 마틴이 좋은 객체 지향 설계의 5가지 원칙을 정리하였다.

1. SRP: 단일 책임 원칙
2. OCP: 개방-폐쇄 원칙
3. LSP: 리스코프 치환 원칙
4. ISP: 인터페이스 분리 원칙
5. DIP: 의존관계 역전 원칙

&nbsp;

### SRP

한 클래스는 **하나의 책임만** 가져야 한다.

변경이 있을 때, 파급 효과가 적도록 설계하는 것이다.

### OCP

소프트웨어 요소는 **확장에는 열려** 있으나 **변경에는 닫혀** 있어야 한다.

인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현한다. (역할과 구현 분리) 

그런데, 다형성을 만족한 설계라도 역할의 변경이 있으면 결국은 코드의 변경은 불가피 할텐데..?

→ 그래서 객체를 생성하고, 연관관계를 맺어주는 별도의 설정자가 필요하다.

### LSP

프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.

약속된 설계 속에서 구현체의 임의 기능 변경은 클린코드에 위반된다.

### ISP

특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.

인터페이스가 명확해지고, 대체 가능성이 높아진다.

### DIP

프로그래머는 “추상화에 의존해야지, 구체화에 의존하면 안된다.”

즉, 구현 클래스에 의존하지 말고, 인터페이스(역할)에 의존하라는 뜻이다.

클라이언트가 구현체 내부에서 무슨 일이 일어나는지 알 필요가 없다. 역할의 변경에만 유연하면 된다.

그런데, 기본적으로 객체 생성은 구현체를 의존하고 있을 뿐더러 OCP와 마찬가지로 역할을 변경하려면 결국 코드의 변경은 불가피하다.

&nbsp;

**결국 다형성 만으로 OCP, DIP를 지킬 수 없다.**